#+title: Ntt Description

* Суть DFT (Дискретное преобразование Фурье)
DFT преобразует последовательность
$a = [a_0, a_1, \dots, a_{N-1}]$
в последовательность
$A = [A_0, A_1,\dots,A_{N-1}]$

$$ A_k = \sum_{n=0}^{N-1} a_n \cdot \omega_N^{kn}, \quad \text{для } k = 0, 1, \dots, N-1 $$

где $\omega_N$ - это примитивный корень N-й степени из единицы:
\begin{aligned}
\omega_N = e^{-\frac{2\pi i}{N}}
\end{aligned}

*Свойство корня из единицы*
$\omega_N^N = 1$
Это значит, что при возведении в степень корень циклически возвращается к единице каждые N-шагов

*Обратное преобразование Фурье (IDFT)*
Чтобы вернуть исходную последовательность из частотной области:
$a_n = \frac{1}{N} \sum_{k=0}^{N-1} A_k \cdot \omega_N^{-kn}$

*Свойство линейности*
DFT превращает свёртку во временной области
в покомпонентное умножение в частотной области:
$$DFT(a * b) = DFT(a) \odot DFT(b)$$
где:
- * - свертка
- $\odot$ - покомпонентное

*Применение к полиномам*
Если у тебя есть два полинома:
$$P(x) = a_0 + a_1x + a_2x^2, \quad Q(x) = b_0 + b_1x + b_2x^2,$$

то их произведение $R(x) = P(x) * Q(x)$
будет иметь степень <= 4:
$$R(x)=r_0 + r_1 x + r_2 x^2 + r_3 x^3 + r_4 x^4$$
где коэффициенты $r_k$ вычисляются как суммы пар $a_i b_i$ с $i + j = k$:
$$r_k = \sum_{i+j=k} a_i b_j$$
и это можно вычислить через преобразование Фурье:
$R = IDFT(DFT(P) \odot DFT(Q))$

/Пример с числами/
$$
a=[1,2,3],\quad b=[4,5,6].$$

\begin{aligned}
r_0 &= a_0 b_0 = 1\cdot 4 = 4,\\
r_1 &= a_0 b_1 + a_1 b_0 = 1\cdot 5 + 2\cdot 4 = 13,\\
r_2 &= a_0 b_2 + a_1 b_1 + a_2 b_0 = 1\cdot 6 + 2\cdot 5 + 3\cdot 4 = 28,\\
r_3 &= a_1 b_2 + a_2 b_1 = 2\cdot 6 + 3\cdot 5 = 27,\\
r_4 &= a_2 b_2  = 3\cdot 6 = 18.
\end{aligned}

$$R(x) = 4 + 13x + 28x^2 + 27x^3 + 18x^4$$

* Суть FFT (Быстрое преобразование Фурье)
FFT - это алгоритм для быстрого вычисления DFT.
Вместо $O(N^2)$ операций (наивный DFT) делает $O(N \log N)$.

*Идея: разделяй и властвуй*

Если N чётное, можно разбить DFT на две части:
- чётные индексы: $a_0, a_2, a_4, \dots$
- нечётные индексы: $a_1, a_3, a_5, \dots$

$$A_k = \sum_{n=0}^{N-1} a_n \cdot \omega_N^{kn}$$

Разобьём сумму:
$$A_k = \sum_{m=0}^{N/2-1} a_{2m} \cdot \omega_N^{k(2m)} + \sum_{m=0}^{N/2-1} a_{2m+1} \cdot \omega_N^{k(2m+1)}$$

$$A_k = \sum_{m=0}^{N/2-1} a_{2m} \cdot \omega_{N/2}^{km} + \omega_N^k \sum_{m=0}^{N/2-1} a_{2m+1} \cdot \omega_{N/2}^{km}$$

Заметь: $\omega_N^{2m} = (\omega_N^2)^m = \omega_{N/2}^m$

Обозначим:
- $E_k$ = DFT чётных элементов
- $O_k$ = DFT нечётных элементов

Тогда:
$$A_k = E_k + \omega_N^k \cdot O_k$$
$$A_{k+N/2} = E_k - \omega_N^k \cdot O_k$$

(второе следует из того, что $\omega_N^{k+N/2} = -\omega_N^k$)

*Пример для N=4*
$$a = [a_0, a_1, a_2, a_3]$$

Чётные: $[a_0, a_2]$, Нечётные: $[a_1, a_3]$

Вычисляем два DFT размера 2:
- $E_0, E_1$ для $[a_0, a_2]$
- $O_0, O_1$ для $[a_1, a_3]$

Затем комбинируем:
\begin{aligned}
A_0 &= E_0 + \omega_4^0 \cdot O_0\\
A_1 &= E_1 + \omega_4^1 \cdot O_1\\
A_2 &= E_0 - \omega_4^0 \cdot O_0\\
A_3 &= E_1 - \omega_4^1 \cdot O_1
\end{aligned}

Эта операция называется *butterfly* (бабочка):
#+begin_example
a[j]     ----+----> a[j] + zeta * a[j+len]
              |
            (зета)
              |
a[j+len] ----+----> a[j] - zeta * a[j+len]
#+end_example

* Суть NTT (Number Theoretic Transform)
NTT - это "FFT, но для целых чисел".

*Главная проблема DFT для криптографии*
В обычном DFT используется $\omega_N = e^{-2\pi i/N}$ - комплексное число.
Но в криптографии нам нужны целые числа по модулю!

*Решение: заменить комплексные корни на корни в конечном поле*

Вместо $\omega_N = e^{-2\pi i/N}$ используем $\omega$ такое, что:
1. $\omega^N \equiv 1 \pmod{q}$ (корень N-й степени из 1)
2. $\omega^k \not\equiv 1 \pmod{q}$ для $0 < k < N$ (примитивный корень)

*Для Kyber: q = 3329, N = 256*

Нужен примитивный корень 256-й степени из единицы по модулю 3329.

Kyber использует $\zeta = 17$ (это корень 256-й степени).

Проверка: $17^{256} \equiv 1 \pmod{3329}$

*Формула NTT*
$$A_k = \sum_{n=0}^{N-1} a_n \cdot \zeta^{kn} \pmod{q}$$

*Обратное преобразование (INTT)*
$$a_n = N^{-1} \sum_{k=0}^{N-1} A_k \cdot \zeta^{-kn} \pmod{q}$$

где $N^{-1}$ - это обратное к N по модулю q.
Для Kyber: $256^{-1} \equiv 3303 \pmod{3329}$

*Преимущества NTT*
1. Все операции - целочисленные (нет комплексных чисел)
2. Нет ошибок округления
3. Быстро: $O(N \log N)$
4. Идеально для умножения полиномов в криптографии

* Программная реализация NTT
Представь, что у тебя есть два больших числа, и ты хочешь их перемножить.
Обычное умножение "в столбик" - это долго (особенно для ОГРОМНЫХ чисел).

NTT - это трюк, который позволяет умножать быстрее:
1. Берём числа
2. Как-то "преобразуем" их (это и есть NTT)
3. Перемножаем что-то простое
4. "Преобразуем обратно"
5. Получаем результат

Как фокус: вместо сложного умножения делаем простые операции.

** Зачем это Kyber'у?

В Kyber постоянно нужно умножать полиномы (это такие выражения типа $3 + 5x + 2x^2$).
Полиномы там большие (256 коэффициентов), умножать их в лоб - медленно.
NTT делает это быстро.

*Аналогия*:
Ты хочешь перевезти кучу вещей через реку.
Можно таскать по одной (медленно) = обычное умножение
Или построить мост и перевезти всё разом (быстро) = NTT

** Как работает твой код (человеческим языком)

** Что такое twiddles?

Это просто заранее посчитанные "волшебные числа".
Представь, что у тебя есть калькулятор, и ты заранее посчитал
результаты каких-то сложных вычислений, чтобы потом не считать их каждый раз.

#+begin_src rust
fn precompute_twiddles() -> [i32; 128] {
    let mut twiddles = [0; 128];
    let mut zeta = 1;
    for i in 0..128 {
        twiddles[i] = zeta;
        zeta = mod_q(zeta * ROOT);  // ROOT = 17
    }
    twiddles
}
#+end_src

Что тут происходит:
- Берём число 1
- Умножаем его на 17, запоминаем результат
- Умножаем результат на 17, запоминаем
- И так 128 раз
- Все результаты по модулю 3329 (то есть если получается больше 3329, отнимаем 3329). число mod 3329 = число - 3329
(если результат всё ещё >= 3329, вычитаем ещё раз, и так далее)

Зачем это нужно? Эти числа понадобятся дальше для "бабочек".

** Что такое butterfly (бабочка)?

Это самая важная операция! Называется так, потому что на схеме
выглядит как крылья бабочки.

#+begin_src rust
let t = mod_q(zeta * a[start + j + len]);
a[start + j + len] = mod_q(a[start + j] - t);
a[start + j] = mod_q(a[start + j] + t);
#+end_src

тут если что A = a[start + j], а B = a[start + j + len]
(из объясненяи дальше)
И кстати надо держать в голове, что умножение производится по модулю Q(3329)

*По-человечески*:
У тебя есть два числа (назовём их A и B).
Ты берёшь одно из "волшебных чисел" (zeta) и делаешь:
1. Умножаешь B на это волшебное число → получаешь t
2. Первое число становится: A + t
3. Второе число становится: A - t

*Зачем это?*
Это как "перетасовка" данных. После многих таких перетасовок
твои данные оказываются в "специальном виде", в котором их легко умножать.

*Аналогия*:
Представь колоду карт.
- Обычный порядок = сложно работать
- После специальной тасовки = легко найти нужную карту
NTT - это и есть такая "специальная тасовка" чисел.

** Как работает весь алгоритм forward?

#+begin_src rust
let mut len = 128;
while len >= 1 {
    for start in (0..256).step_by(len * 2) {
        let zeta = self.twiddles[k % 128];
        for j in 0..len {
            // butterfly операция
        }
        k += 1;
    }
    len /= 2;
}
#+end_src

*Пошагово*:

Представь, что у тебя 256 чисел в ряд: [a₀, a₁, a₂, ..., a₂₅₅]

*Шаг 1*: len = 128
Разбиваем массив пополам:
- Первая половина: $[a_0...a_{127}]$
- Вторая половина: $[a_{128}...a_{255}]$
Применяем бабочку между a₀ и $a_{128}$, между a₁ и $a_{129}$, и т.д.

*Шаг 2*: len = 64
Теперь разбиваем на 4 части по 64 элемента.
В каждой паре применяем бабочки.

*Шаг 3*: len = 32
Разбиваем на 8 частей по 32...

...и так далее, пока не дойдём до len = 1.

*Аналогия*:
Это как сортировка слиянием, если ты о ней слышал.
Сначала работаешь с большими кусками, потом с меньшими.
Только вместо сортировки мы делаем "преобразование".

** Что получается в итоге?

После всех этих бабочек твой массив превратился из "обычного вида"
в "NTT-вид". В этом виде умножать полиномы легко - просто
перемножаешь элементы попарно:
- результат[0] = a[0] * b[0]
- результат[1] = a[1] * b[1]
- ...

А потом делаешь обратное NTT и получаешь правильный результат умножения полиномов!

*Что реально нужно понимать для реализации?*

** Обязательно понять:
1. *Бабочка* - это основа всего. Берёшь два числа, одно волшебное число,
   делаешь A+t и A-t. Всё.

2. *Алгоритм работает уровнями* - сначала большие блоки, потом маленькие.
   На каждом уровне делаешь бабочки с правильными волшебными числами.

3. *Волшебные числа (twiddles)* - это просто степени 17 по модулю 3329.
   Считаются один раз заранее.

** Можно не понимать (пока):
- Почему именно 17? (это математика, можешь принять как данность)
- Откуда взялась формула DFT? (историческая справка)
- Доказательства, что это работает (поверь на слово)

** Алгоритм действий для реализации*

1. Считаешь twiddles (степени 17): 1, 17, 17², 17³...
2. Начинаешь с len=128
3. Разбиваешь массив на блоки размера len*2
4. В каждом блоке применяешь бабочки между первой и второй половиной
5. len делишь пополам
6. Повторяешь, пока len >= 1

Вот и всё! Это и есть forward NTT.

*Inverse NTT (обратное преобразование)*

Делаешь почти то же самое, но:
1. Вместо степеней 17 используешь степени 17⁻¹ (обратное число)
2. В конце всё умножаешь на 256⁻¹ (это типа "нормализация")

Для Kyber эти числа уже известны:
- 17⁻¹ = 1175 (mod 3329)
- 256⁻¹ = 3303 (mod 3329)

** Полная картина умножения в Kyber:
1. Есть два полинома f(x) и g(x)
   f: [a₀, a₁, ..., a₂₅₅]
   g: [b₀, b₁, ..., b₂₅₅]

2. Применяем NTT к обоим:
   F = NTT(f)
   G = NTT(g)

3. Перемножаем поэлементно:
   H[i] = F[i] * G[i]  для всех i

4. Применяем обратное NTT:
   h = INTT(H)

5. Получаем h(x) = f(x) * g(x)

В обычном виде без NTT:
f(x) * g(x) → нужно много операций (медленно)
