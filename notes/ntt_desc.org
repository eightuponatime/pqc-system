#+title: Ntt Description

* Суть DFT (Дискретное преобразование Фурье)
DFT преобразует последовательность
$a = [a_0, a_1, \dots, a_{N-1}]$
в последовательность
$A = [A_0, A_1,\dots,A_{N-1}]$

$$ A_k = \sum_{n=0}^{N-1} a_n \cdot \omega_N^{kn}, \quad \text{для } k = 0, 1, \dots, N-1 $$

где $\omega_N$ - это примитивный корень N-й степени из единицы:
\begin{aligned}
\omega_N = e^{-\frac{2\pi i}{N}}
\end{aligned}

*Свойство корня из единицы*
$\omega_N^N = 1$
Это значит, что при возведении в степень корень циклически возвращается к единице каждые N-шагов

*Обратное преобразование Фурье (IDFT)*
Чтобы вернуть исходную последовательность из частотной области:
$a_n = \frac{1}{N} \sum_{k=0}^{N-1} A_k \cdot \omega_N^{-kn}$

*Свойство линейности*
DFT превращает свёртку во временной области
в покомпонентное умножение в частотной области:
$$DFT(a * b) = DFT(a) \odot DFT(b)$$
где:
- * - свертка
- $\odot$ - покомпонентное

*Применение к полиномам*
Если у тебя есть два полинома:
$$P(x) = a_0 + a_1x + a_2x^2, \quad Q(x) = b_0 + b_1x + b_2x^2,$$

то их произведение $R(x) = P(x) * Q(x)$
будет иметь степень <= 4:
$$R(x)=r_0 + r_1 x + r_2 x^2 + r_3 x^3 + r_4 x^4$$
где коэффициенты $r_k$ вычисляются как суммы пар $a_i b_i$ с $i + j = k$:
$$r_k = \sum_{i+j=k} a_i b_j$$
и это можно вычислить через преобразование Фурье:
$R = IDFT(DFT(P) \odot DFT(Q))$

/Пример с числами/
$$
a=[1,2,3],\quad b=[4,5,6].$$

\begin{aligned}
r_0 &= a_0 b_0 = 1\cdot 4 = 4,\\
r_1 &= a_0 b_1 + a_1 b_0 = 1\cdot 5 + 2\cdot 4 = 13,\\
r_2 &= a_0 b_2 + a_1 b_1 + a_2 b_0 = 1\cdot 6 + 2\cdot 5 + 3\cdot 4 = 28,\\
r_3 &= a_1 b_2 + a_2 b_1 = 2\cdot 6 + 3\cdot 5 = 27,\\
r_4 &= a_2 b_2  = 3\cdot 6 = 18.
\end{aligned}

$$R(x) = 4 + 13x + 28x^2 + 27x^3 + 18x^4$$

* Суть FFT (Быстрое преобразование Фурье)
FFT - это алгоритм для быстрого вычисления DFT.
Вместо $O(N^2)$ операций (наивный DFT) делает $O(N \log N)$.

*Идея: разделяй и властвуй*

Если N чётное, можно разбить DFT на две части:
- чётные индексы: $a_0, a_2, a_4, \dots$
- нечётные индексы: $a_1, a_3, a_5, \dots$

$$A_k = \sum_{n=0}^{N-1} a_n \cdot \omega_N^{kn}$$

Разобьём сумму:
$$A_k = \sum_{m=0}^{N/2-1} a_{2m} \cdot \omega_N^{k(2m)} + \sum_{m=0}^{N/2-1} a_{2m+1} \cdot \omega_N^{k(2m+1)}$$

$$A_k = \sum_{m=0}^{N/2-1} a_{2m} \cdot \omega_{N/2}^{km} + \omega_N^k \sum_{m=0}^{N/2-1} a_{2m+1} \cdot \omega_{N/2}^{km}$$

Заметь: $\omega_N^{2m} = (\omega_N^2)^m = \omega_{N/2}^m$

Обозначим:
- $E_k$ = DFT чётных элементов
- $O_k$ = DFT нечётных элементов

Тогда:
$$A_k = E_k + \omega_N^k \cdot O_k$$
$$A_{k+N/2} = E_k - \omega_N^k \cdot O_k$$

(второе следует из того, что $\omega_N^{k+N/2} = -\omega_N^k$)

*Пример для N=4*
$$a = [a_0, a_1, a_2, a_3]$$

Чётные: $[a_0, a_2]$, Нечётные: $[a_1, a_3]$

Вычисляем два DFT размера 2:
- $E_0, E_1$ для $[a_0, a_2]$
- $O_0, O_1$ для $[a_1, a_3]$

Затем комбинируем:
\begin{aligned}
A_0 &= E_0 + \omega_4^0 \cdot O_0\\
A_1 &= E_1 + \omega_4^1 \cdot O_1\\
A_2 &= E_0 - \omega_4^0 \cdot O_0\\
A_3 &= E_1 - \omega_4^1 \cdot O_1
\end{aligned}

Эта операция называется *butterfly* (бабочка):
#+begin_example
a[j]     ----+----> a[j] + zeta * a[j+len]
              |
            (зета)
              |
a[j+len] ----+----> a[j] - zeta * a[j+len]
#+end_example

* Суть NTT (Number Theoretic Transform)
NTT - это "FFT, но для целых чисел".

*Главная проблема DFT для криптографии*
В обычном DFT используется $\omega_N = e^{-2\pi i/N}$ - комплексное число.
Но в криптографии нам нужны целые числа по модулю!

*Решение: заменить комплексные корни на корни в конечном поле*

Вместо $\omega_N = e^{-2\pi i/N}$ используем $\omega$ такое, что:
1. $\omega^N \equiv 1 \pmod{q}$ (корень N-й степени из 1)
2. $\omega^k \not\equiv 1 \pmod{q}$ для $0 < k < N$ (примитивный корень)

*Для Kyber: q = 3329, N = 256*

Нужен примитивный корень 256-й степени из единицы по модулю 3329.

Kyber использует $\zeta = 17$ (это корень 256-й степени).

Проверка: $17^{256} \equiv 1 \pmod{3329}$

*Формула NTT*
$$A_k = \sum_{n=0}^{N-1} a_n \cdot \zeta^{kn} \pmod{q}$$

*Обратное преобразование (INTT)*
$$a_n = N^{-1} \sum_{k=0}^{N-1} A_k \cdot \zeta^{-kn} \pmod{q}$$

где $N^{-1}$ - это обратное к N по модулю q.
Для Kyber: $256^{-1} \equiv 3303 \pmod{3329}$

*Преимущества NTT*
1. Все операции - целочисленные (нет комплексных чисел)
2. Нет ошибок округления
3. Быстро: $O(N \log N)$
4. Идеально для умножения полиномов в криптографии

* Программная реализация NTT
Представь, что у тебя есть два больших числа, и ты хочешь их перемножить.
Обычное умножение "в столбик" - это долго (особенно для ОГРОМНЫХ чисел).

NTT - это трюк, который позволяет умножать быстрее:
1. Берём числа
2. Как-то "преобразуем" их (это и есть NTT)
3. Перемножаем что-то простое
4. "Преобразуем обратно"
5. Получаем результат

Как фокус: вместо сложного умножения делаем простые операции.

** Зачем это Kyber'у?

В Kyber постоянно нужно умножать полиномы (это такие выражения типа $3 + 5x + 2x^2$).
Полиномы там большие (256 коэффициентов), умножать их в лоб - медленно.
NTT делает это быстро.

*Аналогия*:
Ты хочешь перевезти кучу вещей через реку.
Можно таскать по одной (медленно) = обычное умножение
Или построить мост и перевезти всё разом (быстро) = NTT

** Как работает твой код (человеческим языком)

** Что такое twiddles?

Это просто заранее посчитанные "волшебные числа".
Представь, что у тебя есть калькулятор, и ты заранее посчитал
результаты каких-то сложных вычислений, чтобы потом не считать их каждый раз.

#+begin_src rust
fn precompute_twiddles() -> [i32; 128] {
    let mut twiddles = [0; 128];
    let mut zeta = 1;
    for i in 0..128 {
        twiddles[i] = zeta;
        zeta = mod_q(zeta * ROOT);  // ROOT = 17
    }
    twiddles
}
#+end_src

Что тут происходит:
- Берём число 1
- Умножаем его на 17, запоминаем результат
- Умножаем результат на 17, запоминаем
- И так 128 раз
- Все результаты по модулю 3329 (то есть если получается больше 3329, отнимаем 3329). число mod 3329 = число - 3329
(если результат всё ещё >= 3329, вычитаем ещё раз, и так далее)

Зачем это нужно? Эти числа понадобятся дальше для "бабочек".

** Что такое butterfly (бабочка)?

Это самая важная операция! Называется так, потому что на схеме
выглядит как крылья бабочки.

#+begin_src rust
let t = mod_q(zeta * a[start + j + len]);
a[start + j + len] = mod_q(a[start + j] - t);
a[start + j] = mod_q(a[start + j] + t);
#+end_src

тут если что A = a[start + j], а B = a[start + j + len]
(из объясненяи дальше)
И кстати надо держать в голове, что умножение производится по модулю Q(3329)

*По-человечески*:
У тебя есть два числа (назовём их A и B).
Ты берёшь одно из "волшебных чисел" (zeta) и делаешь:
1. Умножаешь B на это волшебное число → получаешь t
2. Первое число становится: A + t
3. Второе число становится: A - t

*Зачем это?*
Это как "перетасовка" данных. После многих таких перетасовок
твои данные оказываются в "специальном виде", в котором их легко умножать.

*Аналогия*:
Представь колоду карт.
- Обычный порядок = сложно работать
- После специальной тасовки = легко найти нужную карту
NTT - это и есть такая "специальная тасовка" чисел.

** Как работает весь алгоритм forward?

#+begin_src rust
let mut len = 128;
while len >= 1 {
    for start in (0..256).step_by(len * 2) {
        let zeta = self.twiddles[k % 128];
        for j in 0..len {
            // butterfly операция
        }
        k += 1;
    }
    len /= 2;
}
#+end_src

*Пошагово*:
На каждом шаге мы делаем бабочки между парами элементов, находящихся на расстоянии ~len~ друг от друга.
С каждым шагом ~len~ уменьшается вдвое, и расстояние между парными элементами сокращается.

Представь, что у тебя 256 чисел в ряд: [a₀, a₁, a₂, ..., a₂₅₅]

*Шаг 1*: len = 128
Разбиваем массив пополам:
- Первая половина: $[a_0...a_{127}]$
- Вторая половина: $[a_{128}...a_{255}]$
Применяем бабочку между a₀ и $a_{128}$, между a₁ и $a_{129}$, и т.д.
То есть применяем бабочки между элементами на расстоянии 128

*Шаг 2*: len = 64
*Количество блоков*: 2 блока по 128 элементов
*Что делаем*: В каждом блоке применяем бабочки между элементами на расстоянии 64
Теперь разбиваем на 4 части по 64 элемента.
В каждой паре применяем бабочки:
Блок 1: (Элементы 0-127);
Блок 2: (Элементы 128-255);

*Шаг 3*: len = 32
*Количество блоков*: 4 блока по 64 элементов
*Что делаем*: В каждом блоке применяем бабочки между элементами на расстоянии 32
Блок 1: 0-63
Блок 2: 64-127
Блок 3: 128-191
Блок 4: 192-255

*Шаг 4*: len = 16
*Количество блоков*: 6 блоков по 32 элементов
*Что делаем*: В каждом блоке применяем бабочки между элементами на расстоянии 16;
*Итого*: 16 бабочек в каждом из 8 блоков = 128 бабочек всего

*Шаг 5*: len = 8
*Количество блоков*: 16 блоков по 16 элементов
*Что делаем*: В каждом блоке применяем бабочки между элементами на расстоянии 8;
*Итого*: 8 бабочек в каждом из 16 блоков = 128 бабочек всего

*Шаг 6*: len = 4
*Количество блоков*: 32 блоков по 8 элементов
*Что делаем*: В каждом блоке применяем бабочки между элементами на расстоянии 4;
*Итого*: 4 бабочек в каждом из 32 блоков = 128 бабочек всего

*Шаг 7*: len = 2
*Количество блоков*: 64 блоков по 4 элементов
*Что делаем*: В каждом блоке применяем бабочки между элементами на расстоянии 2;
*Итого*: 2 бабочки в каждом из 64 блоков = 128 бабочек всего

...и так далее, пока не дойдём до len = 1.

*Шаг 8*: len = 1 (FINAL)
*Количество блоков*: 128 блоков по 2 элементов
*Что делаем*: В каждом блоке бабочка между соседними элементами
*Итого*: 1 бабочка в каждом из 128 блоков = 128 бабочек всего
| Шаг | len | Кол-во блоков | Размер блока | Бабочек в блоке | Всего бабочек |
|-----+-----+---------------+--------------+-----------------+---------------|
|   1 | 128 |             1 |          256 |             128 |           128 |
|   2 |  64 |             2 |          128 |              64 |           128 |
|   3 |  32 |             4 |           64 |              32 |           128 |
|   4 |  16 |             8 |           32 |              16 |           128 |
|   5 |   8 |            16 |           16 |               8 |           128 |
|   6 |   4 |            32 |            8 |               4 |           128 |
|   7 |   2 |            64 |            4 |               2 |           128 |
|   8 |   1 |           128 |            2 |               1 |           128 |

*Аналогия*:
Это как сортировка слиянием, если ты о ней слышал.
Сначала работаешь с большими кусками, потом с меньшими.
Только вместо сортировки мы делаем "преобразование".

** Что получается в итоге?

После всех этих бабочек твой массив превратился из "обычного вида"
в "NTT-вид". В этом виде умножать полиномы легко - просто
перемножаешь элементы попарно:
- результат[0] = a[0] * b[0]
- результат[1] = a[1] * b[1]
- ...

А потом делаешь обратное NTT и получаешь правильный результат умножения полиномов!

*Что реально нужно понимать для реализации?*

** Обязательно понять:
1. *Бабочка* - это основа всего. Берёшь два числа, одно волшебное число,
   делаешь A+t и A-t. Всё.

2. *Алгоритм работает уровнями* - сначала большие блоки, потом маленькие.
   На каждом уровне делаешь бабочки с правильными волшебными числами.

3. *Волшебные числа (twiddles)* - это просто степени 17 по модулю 3329.
   Считаются один раз заранее.

** Можно не понимать (пока):
- Почему именно 17? (это математика, можешь принять как данность)
- Откуда взялась формула DFT? (историческая справка)
- Доказательства, что это работает (поверь на слово)

** Алгоритм действий для реализации*

1. Считаешь twiddles (степени 17): 1, 17, 17², 17³...
2. Начинаешь с len=128
3. Разбиваешь массив на блоки размера len*2
4. В каждом блоке применяешь бабочки между первой и второй половиной
5. len делишь пополам
6. Повторяешь, пока len >= 1

Вот и всё! Это и есть forward NTT.

*Inverse NTT (обратное преобразование)*

Делаешь почти то же самое, но:
1. Вместо степеней 17 используешь степени 17⁻¹ (обратное число)
2. В конце всё умножаешь на 256⁻¹ (это типа "нормализация")

Для Kyber эти числа уже известны:
- 17⁻¹ = 1175 (mod 3329)
- 256⁻¹ = 3303 (mod 3329)

** Полная картина умножения в Kyber:
1. Есть два полинома f(x) и g(x)
   f: [a₀, a₁, ..., a₂₅₅]
   g: [b₀, b₁, ..., b₂₅₅]

2. Применяем NTT к обоим:
   F = NTT(f)
   G = NTT(g)

3. Перемножаем поэлементно:
   H[i] = F[i] * G[i]  для всех i

4. Применяем обратное NTT:
   h = INTT(H)

5. Получаем h(x) = f(x) * g(x)

В обычном виде без NTT:
f(x) * g(x) → нужно много операций (медленно)

* Inverse NTT (обратное преобразование)
** Главная идея
Inverse NTT делает *обратное* преобразование: из NTT-представления возвращает в обычное.
Если ~forward~ превращает коэффициенты полинома в "частотное представление",
то ~inverse~ превращает "частотное представление" обратно в коэффициенты.

** Отличия от forward

Inverse отличается от forward *двумя вещами*:

1. *Используем обратные twiddles* (степени $\zeta^{-1}$ вместо $\zeta$) (Прим: $\zeta$ -> zeta)
2. *В конце умножаем всё на $N^{-1}$* (нормализация)

** Что такое обратные значения?

*** Обратное к zeta (корню)

Для Kyber:
- ~ROOT = 17~ (это zeta, корень 256-й степени из 1)
- ~ROOT_INV = 1175~ (это $zeta^{-1}$, обратное к 17 по модулю 3329)

Проверка: $17 \times 1175 \equiv 1 \pmod{3329}$

*** Обратное к N

- ~N = 256~
- ~N_INV = 3303~ (это $256^{-1}$ по модулю 3329)

Проверка: $256 \times 3303 \equiv 1 \pmod{3329}$

** Алгоритм inverse (пошагово)

#+begin_src rust
    fn inverse(&self, _a: &mut [i32; 256]) {
        let mut len = 1;
        let mut k = 127;

        while len <= 128 {
            for start in (0..256).step_by(len * 2) {
                let zeta = self.twiddles_inv[k % 128];

                for j in 0..len {
                    let t = mod_q(zeta * a[start + j + len]);
                    a[start + j + len] = mod_q(a[start + j] - t);
                    a[start + j] = mod_q(a[start + j] + t);
                }

                k = k.wrapping_sub(1);
            }
            len *= 2;
        }

        for i in 0..256 {
            a[i] = mod_q(a[i] * N_INV);
        }
    }
#+end_src

Inverse работает *почти так же*, как forward, но:
- Алгоритм идёт в *обратном порядке*: от len=1 до len=128
- Используются *обратные twiddles*

*** Шаг 1: len = 1
*Количество блоков*: 128 блоков по 2 элемента
Это *зеркально* последнему шагу forward!
*** Шаг 2: len = 2
*Количество блоков*: 64 блока по 4 элемента
Пары на расстоянии 2.
*** Шаг 3: len = 4
*Количество блоков*: 32 блока по 8 элементов
Пары на расстоянии 4.
*** ...и так далее до len = 128
*** Финальный шаг: len = 128
*Количество блоков*: 1 блок из 256 элементов
Это *зеркально* первому шагу forward!


*** Нормализация

После всех бабочек умножаем каждый элемент на $N^{-1} = 3303$:

#+begin_src rust
for i in 0..256 {
    a[i] = mod_q(a[i] * 3303);
}
#+end_src

** Почему inverse работает?

*** Математическая суть

Forward NTT вычисляет:
$$A_k = \sum_{n=0}^{255} a_n \cdot \zeta^{kn}$$

Inverse NTT вычисляет:
$$a_n = \frac{1}{256} \sum_{k=0}^{255} A_k \cdot \zeta^{-kn}$$

Если применить inverse после forward, получим исходный массив:
$$\text{inverse}(\text{forward}(a)) = a$$

*** Интуитивное объяснение

Представь, что forward - это шифрование:
- Берём текст, применяем серию преобразований
- Получаем зашифрованное сообщение

Inverse - это расшифровка:
- Применяем те же преобразования *в обратном порядке*
- Используем *обратные ключи* (twiddles_inv вместо twiddles)
- В конце "нормализуем" результат (умножаем на N_INV)
- Получаем исходный текст обратно
